## Context

Next.js's compiler (Webpack/Turbopack) automatically inlines `process.env.NEXT_PUBLIC_*` variables during the build. To avoid this and achieve runtime injection, `@runtime-env` uses a global variable. However, `globalThis.runtimeEnv` has shown issues during Next.js prerendering, and is not as idiomatic as using `process.env` or `window`.

## Decisions

### 1. Robust `runtimeEnv` replacement

We will continue to support the `runtimeEnv` global in user code, but the plugin will automatically replace it with:
`(typeof window !== 'undefined' ? window : process.env).runtimeEnv`

**Rationale**:

- Next.js's compiler does NOT inline nested properties of `process.env` (e.g., `process.env.runtimeEnv.X` is safe).
- This pattern is more robust against Next.js optimizations that might affect `globalThis` or direct global variable access during build-time static generation.
- **Developer Experience**: Users don't need to change their existing code from `runtimeEnv.X` to something else.
- **Portability**: The same code works on both client and server.
- **Implementation**: We use Webpack's `DefinePlugin` for the standard Webpack bundler. For Turbopack (Next.js 15+), we use `string-replace-loader` via `turbopack.rules` (and `experimental.turbo.rules` for earlier versions), as it is an officially supported mechanism for code transformation in Turbopack. This ensures that the `runtimeEnv` identifier is consistently replaced with the robust access pattern across both bundlers.

### 2. Build-time Placeholders

The plugin will populate `process.env.runtimeEnv` with placeholders (e.g., `"${NEXT_PUBLIC_VAR}"`) during the `PHASE_PRODUCTION_BUILD`.

**Rationale**:

- This ensures that code accessing these variables during prerendering does not crash.
- It prevents real sensitive values from being baked into the static HTML files generated at build time.

### 3. No CLI Changes

We will NOT modify the `runtime-env` CLI. TypeScript augmentations for `runtimeEnv` are already generated by `gen-ts`. We might need to ensure `process.env.runtimeEnv` is also typed for cases where users want to use it explicitly.

## Risks / Trade-offs

- **Complexity**: The plugin now needs to inject Webpack configuration and handle placeholders during build.
- **Unexpected side effects**: `DefinePlugin` performs a literal text replacement. We must ensure it doesn't replace `runtimeEnv` in contexts where it shouldn't (though `runtimeEnv` is a relatively unique name).
