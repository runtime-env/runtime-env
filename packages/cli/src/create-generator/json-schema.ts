import serializeJavascript from "serialize-javascript";
import Ajv from "ajv";
import AjvFormats from "ajv-formats";
import { parse } from "dotenv";
import {
  CreateGenerator,
  CreateGeneratorReturnType,
} from "../create-generator";
import { readFileSync } from "fs";
import { compile } from "json-schema-to-typescript";
import { template } from "lodash";

export const createGeneratorForJSONSchema: CreateGenerator = async ({
  globalVariableName,
  envSchemaFilePath,
  envFilePath,
  userEnvironment,
}) => {
  return <CreateGeneratorReturnType>{
    interpolate: async (input) => {
      const parsedEnv = await parseEnv({
        envFilePath,
        envSchemaFilePath,
        userEnvironment,
      });
      const data = convertEnvToData(parsedEnv);
      const serializedData = serializeLeafNodes(data);
      const content = template(input, {
        variable: globalVariableName,
      })(serializedData);
      return content;
    },
    generateJs: async () => {
      const parsedEnv = await parseEnv({
        envFilePath,
        envSchemaFilePath,
        userEnvironment,
      });
      const content = [
        "// Generated by '@runtime-env/cli'",
        "",
        `globalThis.${globalVariableName} = {`,
        ...Object.entries(parsedEnv).map(
          ([key, value]) => `  "${key}": ${value},`,
        ),
        "}",
        "",
      ].join("\n");
      return content;
    },
    generateTs: async () => {
      const envSchemaFileContent = readFileSync(envSchemaFilePath, "utf8");
      const envSchemaFileJSON = JSON.parse(envSchemaFileContent);
      const result = await compile(envSchemaFileJSON, globalVariableName, {
        bannerComment: `
// Generated by '@runtime-env/cli'

type Primitive = undefined | null | boolean | string | number

type DeepReadonly<T> =
  T extends Primitive ? T :
    T extends Array<infer U> ? DeepReadonlyArray<U> :
      DeepReadonlyObject<T>

type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>

type DeepReadonlyObject<T> = {
  readonly [K in keyof T]: DeepReadonly<T[K]>
}
        `,
        additionalProperties: false,
      });
      const capitalCaseGlobalVariableName =
        globalVariableName.charAt(0).toUpperCase() +
        globalVariableName.slice(1);
      return (
        result
          .replace(
            /export interface (\S+) /,
            `
declare global {
  var ${globalVariableName}: ${capitalCaseGlobalVariableName}
}

export type ${capitalCaseGlobalVariableName} = DeepReadonly<
            `.trim(),
          )
          .trim() + ">\n"
      );
    },
  };
};

type ParseEnv = (_: {
  envFilePath: null | string | string[];
  envSchemaFilePath: string;
  userEnvironment: boolean;
}) => Promise<Record<string, any>>;
const parseEnv: ParseEnv = async ({
  envFilePath,
  envSchemaFilePath,
  userEnvironment,
}) => {
  const ajv = new Ajv({
    allErrors: true,
    strict: true,
    coerceTypes: false,
  });
  AjvFormats(ajv);
  const envSchemaFileContent = readFileSync(envSchemaFilePath, "utf8");
  const envSchemaFileJSON = JSON.parse(envSchemaFileContent);
  const env = (() => {
    let env: Record<string, string> = {};
    const envFilePaths = Array.isArray(envFilePath)
      ? envFilePath
      : envFilePath !== null
        ? [envFilePath]
        : [];
    envFilePaths.forEach((envFilePath) => {
      const envFileContent = readFileSync(envFilePath, "utf8");
      const parsedEnvFileContent = parse(envFileContent);
      env = { ...env, ...parsedEnvFileContent };
    });
    if (userEnvironment) {
      env = { ...env, ...(process.env as Record<string, string>) };
    }
    return env;
  })();

  if (envSchemaFileJSON.type !== "object") {
    throw Error('schema is invalid: data/type must be "object"');
  }
  if (
    Object.getPrototypeOf(envSchemaFileJSON.properties ?? "").constructor !==
    Object
  ) {
    throw Error("schema is invalid: data/properties must be object");
  }

  const parsedEnv: Record<string, any> = {};
  const errors: string[] = [];
  Object.keys(envSchemaFileJSON.properties).forEach((property) => {
    const value =
      envSchemaFileJSON.properties[property].type === "string"
        ? env[property]
        : (() => {
            try {
              return JSON.parse(env[property]);
            } catch {
              return env[property];
            }
          })();
    const propertySchema = {
      type: envSchemaFileJSON.type,
      properties: {
        [property]: envSchemaFileJSON.properties[property],
      },
      required: (envSchemaFileJSON.required ?? []).includes(property)
        ? [property]
        : [],
    };
    if (ajv.validate(propertySchema, { [property]: value })) {
      parsedEnv[property] = serializeJavascript(value);
    } else {
      errors.push(JSON.stringify(ajv.errors));
    }
  });

  if (errors.length) {
    throw TypeError(["", ...errors].join("\n  "));
  }

  return parsedEnv;
};

type ConvertEnvToData = (env: Record<string, any>) => Record<string, any>;
const convertEnvToData: ConvertEnvToData = (env) => {
  return Object.entries(env).reduce((acc, [key, value]) => {
    try {
      return Object.assign(acc, { [key]: JSON.parse(value) });
    } catch {
      return Object.assign(acc, { [key]: "" });
    }
  }, {});
};

type SerializeLeafNodes = (env: any) => Record<string, any>;
const serializeLeafNodes: SerializeLeafNodes = (env) => {
  if (Array.isArray(env)) {
    return env.map((value) => serializeLeafNodes(value));
  } else if (typeof env === "object" && env !== null) {
    return Object.entries(env).reduce(
      (acc, [key, value]) =>
        Object.assign(acc, { [key]: serializeLeafNodes(value) }),
      {},
    );
  } else {
    return serializeJavascript(env).slice(1, -1);
  }
};
