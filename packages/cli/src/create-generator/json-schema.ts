import serializeJavascript from "serialize-javascript";
import Ajv from "ajv";
import AjvFormats from "ajv-formats";
import { parse } from "dotenv";
import {
  CreateGenerator,
  CreateGeneratorReturnType,
} from "../create-generator";
import { readFileSync } from "fs";
import { compile } from "json-schema-to-typescript";
import { template } from "lodash";
import throwError from "../throwError";

export const createGeneratorForJSONSchema: CreateGenerator = async ({
  globalVariableName,
  schemaFile,
  envFile,
  userEnvironment,
}) => {
  return <CreateGeneratorReturnType>{
    interpolate: async (input) => {
      const parsedEnv = await parseEnv({
        envFile,
        schemaFile,
        userEnvironment,
      });
      const data = convertEnvToData(parsedEnv);
      const serializedData = serializeLeafNodes(data);
      const content = template(input, {
        variable: globalVariableName,
      })(serializedData);
      return content;
    },
    generateJs: async () => {
      const parsedEnv = await parseEnv({
        envFile,
        schemaFile,
        userEnvironment,
      });
      const content = [
        "// Generated by '@runtime-env/cli'",
        "",
        `globalThis.${globalVariableName} = {`,
        ...Object.entries(parsedEnv).map(
          ([key, value]) => `  "${key}": ${value},`,
        ),
        "}",
        "",
      ].join("\n");
      return content;
    },
    generateTs: async () => {
      let envSchemaFileContent = "";
      try {
        envSchemaFileContent = readFileSync(schemaFile, "utf8");
      } catch {
        throwError(`schema file not found: no such file, open '${schemaFile}'`);
      }
      const envSchemaFileJSON = JSON.parse(envSchemaFileContent);
      const result = await compile(envSchemaFileJSON, globalVariableName, {
        bannerComment: `
// Generated by '@runtime-env/cli'

type Primitive = undefined | null | boolean | string | number

type DeepReadonly<T> =
  T extends Primitive ? T :
    T extends Array<infer U> ? DeepReadonlyArray<U> :
      DeepReadonlyObject<T>

type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>

type DeepReadonlyObject<T> = {
  readonly [K in keyof T]: DeepReadonly<T[K]>
}
        `,
        additionalProperties: false,
      });
      const capitalCaseGlobalVariableName =
        globalVariableName.charAt(0).toUpperCase() +
        globalVariableName.slice(1);
      return (
        result
          .replace(
            /export interface (\S+) /,
            `
declare global {
  var ${globalVariableName}: ${capitalCaseGlobalVariableName}
}

export type ${capitalCaseGlobalVariableName} = DeepReadonly<
            `.trim(),
          )
          .trim() + ">\n"
      );
    },
  };
};

type ParseEnv = (_: {
  envFile: null | string | string[];
  schemaFile: string;
  userEnvironment: boolean;
}) => Promise<Record<string, any>>;
const parseEnv: ParseEnv = async ({ envFile, schemaFile, userEnvironment }) => {
  const ajv = new Ajv({
    allErrors: true,
    strict: true,
    coerceTypes: false,
  });
  AjvFormats(ajv);
  let envSchemaFileContent = "";
  try {
    envSchemaFileContent = readFileSync(schemaFile, "utf8");
  } catch {
    throwError(`schema file not found: no such file, open '${schemaFile}'`);
  }
  const envSchemaFileJSON = JSON.parse(envSchemaFileContent);
  const env = (() => {
    let env: Record<string, string> = {};
    const envFilePaths = Array.isArray(envFile)
      ? envFile
      : envFile !== null
        ? [envFile]
        : [];
    envFilePaths.forEach((envFile) => {
      let envFileContent = "";
      try {
        envFileContent = readFileSync(envFile, "utf8");
      } catch {
        throwError(`env file not found: no such file, open '${envFile}'`);
      }
      const parsedEnvFileContent = parse(envFileContent);
      env = { ...env, ...parsedEnvFileContent };
    });
    if (userEnvironment) {
      env = { ...env, ...(process.env as Record<string, string>) };
    }
    return env;
  })();

  if (envSchemaFileJSON.type !== "object") {
    throwError('schema is invalid: data/type must be "object"');
  }
  if (
    Object.getPrototypeOf(envSchemaFileJSON.properties ?? "").constructor !==
    Object
  ) {
    throwError("schema is invalid: data/properties must be object");
  }
  if (
    Array.isArray(Object.getPrototypeOf(envSchemaFileJSON.required ?? [])) ===
    false
  ) {
    throwError("schema is invalid: data/required must be array");
  }
  (envSchemaFileJSON.required ?? []).forEach(
    (property: unknown, index: number) => {
      if (typeof property !== "string") {
        throwError(`schema is invalid: data/required/${index} must be string`);
      }
    },
  );

  const parsedEnv: Record<string, any> = {};
  const errors: string[] = [];
  Object.keys(envSchemaFileJSON.properties).forEach((property) => {
    const value =
      envSchemaFileJSON.properties[property].type === "string"
        ? env[property]
        : (() => {
            try {
              return JSON.parse(env[property]);
            } catch {
              return env[property];
            }
          })();
    const propertySchema = {
      type: envSchemaFileJSON.type,
      properties: {
        [property]: envSchemaFileJSON.properties[property],
      },
      required: (envSchemaFileJSON.required ?? []).includes(property)
        ? [property]
        : [],
    };
    try {
      if (ajv.validate(propertySchema, { [property]: value })) {
        parsedEnv[property] = serializeJavascript(value);
      } else {
        errors.push("env is invalid: " + JSON.stringify(ajv.errors));
      }
    } catch (error) {
      errors.push(String(error).replace("Error: ", ""));
    }
  });

  if (errors.length) {
    throwError(...errors);
  }

  return parsedEnv;
};

type ConvertEnvToData = (env: Record<string, any>) => Record<string, any>;
const convertEnvToData: ConvertEnvToData = (env) => {
  return Object.entries(env).reduce((acc, [key, value]) => {
    try {
      return Object.assign(acc, { [key]: JSON.parse(value) });
    } catch {
      return Object.assign(acc, { [key]: "" });
    }
  }, {});
};

type SerializeLeafNodes = (env: any) => Record<string, any>;
const serializeLeafNodes: SerializeLeafNodes = (env) => {
  if (Array.isArray(env)) {
    return env.map((value) => serializeLeafNodes(value));
  } else if (typeof env === "object" && env !== null) {
    return Object.entries(env).reduce(
      (acc, [key, value]) =>
        Object.assign(acc, { [key]: serializeLeafNodes(value) }),
      {},
    );
  } else {
    return serializeJavascript(env).slice(1, -1);
  }
};
